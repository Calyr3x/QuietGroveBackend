package telegram

import (
	"context"
	"fmt"
	"github.com/calyrexx/QuietGrooveBackend/internal/entities"
	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"strings"
)

func (a *Adapter) ReservationCreatedForAdmin(msg entities.ReservationCreatedMessage) error {
	ctx := context.Background()

	text := fmt.Sprintf(
		"‚úÖ *–ù–æ–≤–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ*\n"+
			"üè† –î–æ–º: %s\n"+
			"üë§ –ì–æ—Å—Ç—å: %s\n"+
			"üìû %s\n"+
			"üìÖ %s ‚Üí %s\n"+
			"üë• %d –≥–æ—Å—Ç–µ–π\n"+
			"üí≥ %d ‚ÇΩ\n",
		msg.House, msg.GuestName, msg.GuestPhone,
		msg.CheckIn.Format("02.01.2006"), msg.CheckOut.Format("02.01.2006"),
		msg.GuestsCount, msg.TotalPrice,
	)

	if len(msg.Bathhouse) > 0 {
		text += "\nüî• *–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ:*\n"
		for _, bath := range msg.Bathhouse {
			fillOpt := ""
			if bath.FillOption != nil {
				fillOpt = "(" + *bath.FillOption + ")"
			}
			text += fmt.Sprintf(
				"‚Ä¢ %s: %s —Å %s –¥–æ %s %s\n",
				bath.Name,
				strings.ReplaceAll(bath.Date, "-", "."),
				bath.TimeFrom,
				bath.TimeTo,
				fillOpt,
			)
		}
	}

	for _, chatID := range a.adminChatIDs {
		_, err := a.bot.SendMessage(ctx,
			&bot.SendMessageParams{
				ChatID:    chatID,
				Text:      text,
				ParseMode: "Markdown",
			},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func (a *Adapter) ReservationCreatedForUser(msg entities.ReservationCreatedMessage, tgID int64) error {
	ctx := context.Background()

	text := fmt.Sprintf(
		"‚úÖ *–í–∞—à–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ!*\n"+
			"üè† –î–æ–º: %s\n"+
			"üìÖ %s ‚Üí %s\n"+
			"üë• %d –≥–æ—Å—Ç–µ–π\n"+
			"üí≥ –°—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è: %d ‚ÇΩ\n"+
			"üìû –ù–∞—à –Ω–æ–º–µ—Ä –¥–ª—è —Å–≤—è–∑–∏: +79867427283\n",
		msg.House,
		msg.CheckIn.Format("02.01.2006"), msg.CheckOut.Format("02.01.2006"),
		msg.GuestsCount, msg.TotalPrice,
	)

	if len(msg.Bathhouse) > 0 {
		text += "\nüî• *–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ:*\n"
		for _, bath := range msg.Bathhouse {
			fillOpt := ""
			if bath.FillOption != nil {
				fillOpt = "(" + *bath.FillOption + ")"
			}
			text += fmt.Sprintf(
				"‚Ä¢ %s: %s —Å %s –¥–æ %s %s\n",
				bath.Name,
				strings.ReplaceAll(bath.Date, "-", "."),
				bath.TimeFrom,
				bath.TimeTo,
				fillOpt,
			)
		}
	}

	_, err := a.bot.SendMessage(ctx,
		&bot.SendMessageParams{
			ChatID:    tgID,
			Text:      text,
			ParseMode: "Markdown",
		},
	)
	if err != nil {
		return err
	}
	return nil
}

func (a *Adapter) myReservationsHandler(ctx context.Context, b *bot.Bot, u *models.Update) {
	tgID := u.Message.Chat.ID

	reservations, err := a.reservationSvc.GetByTelegramID(ctx, tgID)
	if err != nil {
		_, err = b.SendMessage(ctx, &bot.SendMessageParams{
			ChatID: tgID,
			Text:   "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
		})
		if err != nil {
			a.logger.Error(err.Error())
		}
		return
	}

	if len(reservations) == 0 {
		_, err = b.SendMessage(ctx, &bot.SendMessageParams{
			ChatID: tgID,
			Text:   "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π.",
		})
		if err != nil {
			a.logger.Error(err.Error())
		}
		return
	}

	rows := make([][]models.InlineKeyboardButton, 0, len(reservations))
	for _, res := range reservations {
		text := fmt.Sprintf(
			"üìÖ %s ‚Üí %s üè† %s",
			res.CheckIn.Format("02.01"), res.CheckOut.Format("02.01"),
			res.HouseName)
		btn := models.InlineKeyboardButton{
			Text:         text,
			CallbackData: fmt.Sprintf("view_resv_%s", res.UUID),
		}
		rows = append(rows, []models.InlineKeyboardButton{btn})
	}

	kb := &models.InlineKeyboardMarkup{
		InlineKeyboard: rows,
	}

	_, err = b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:      tgID,
		Text:        "–í–∞—à–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:",
		ReplyMarkup: kb,
	})
	if err != nil {
		a.logger.Error(err.Error())
	}
}

func (a *Adapter) viewReservationCallback(ctx context.Context, b *bot.Bot, update *models.Update) {
	if update.CallbackQuery == nil {
		return
	}
	q := update.CallbackQuery

	uuid := strings.TrimPrefix(q.Data, "view_resv_")
	tgID := q.Message.Message.Chat.ID

	reservation, err := a.reservationSvc.GetDetailsByUUID(ctx, tgID, uuid)
	if err != nil {
		_, err = b.AnswerCallbackQuery(ctx, &bot.AnswerCallbackQueryParams{
			CallbackQueryID: q.ID,
			Text:            "–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.",
			ShowAlert:       true,
		})
		if err != nil {
			a.logger.Error(err.Error())
		}
		return
	}

	var statusMsg string
	switch reservation.Status {
	case "confirmed":
		statusMsg = "–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ ‚úÖ"
	case "cancelled":
		statusMsg = "–û—Ç–º–µ–Ω–µ–Ω–æ ‚ùå"
	case "checked_in":
		statusMsg = "–í –ø—Ä–æ—Ü–µ—Å—Å–µ ‚ñ∂"
	case "check_out":
		statusMsg = "–ó–∞–≤–µ—Ä—à–µ–Ω–æ ‚úÖ"
	}

	msg := fmt.Sprintf(
		"üè† –î–æ–º: %s\n"+
			"üìÖ %s ‚Üí %s\n"+
			"üë• %d –≥–æ—Å—Ç–µ–π\n"+
			"üí≥ –°—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è: %d‚ÇΩ\n"+
			"‚ÑπÔ∏è –°—Ç–∞—Ç—É—Å: %s\n",
		reservation.HouseName,
		reservation.CheckIn.Format("02.01.2006"),
		reservation.CheckOut.Format("02.01.2006"),
		reservation.GuestsCount,
		reservation.TotalPrice,
		statusMsg,
	)

	if len(reservation.Bathhouse) > 0 {
		msg += "\nüî• *–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω—ã –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ*:\n"
		for _, bath := range reservation.Bathhouse {
			fillOpt := ""
			if bath.FillOptionName != nil {
				fillOpt = "(" + *bath.FillOptionName + ")"
			}
			msg += fmt.Sprintf("‚Ä¢ %s: %s —Å %s –¥–æ %s %s\n", bath.Name, bath.Date, bath.TimeFrom, bath.TimeTo, fillOpt)
		}
	}

	photo := &models.InputFileString{Data: reservation.ImageURL}

	_, err = b.SendPhoto(ctx, &bot.SendPhotoParams{
		ChatID:    tgID,
		Photo:     photo,
		Caption:   msg,
		ParseMode: "Markdown",
	})
	if err != nil {
		a.logger.Error(err.Error())
	}
}
